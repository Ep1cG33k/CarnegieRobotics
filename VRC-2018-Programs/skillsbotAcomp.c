#pragma config(Sensor, in1,    battery,        sensorAnalog)
#pragma config(Sensor, in2,    lineFollowLeft, sensorLineFollower)
#pragma config(Sensor, in3,    lineFollowRight, sensorLineFollower)
#pragma config(Sensor, dgtl1,  frontLift,      sensorTouch)
#pragma config(Sensor, dgtl2,  backLift,       sensorTouch)
#pragma config(Sensor, dgtl3,  red2,           sensorLEDtoVCC)
#pragma config(Sensor, dgtl4,  red3,           sensorLEDtoVCC)
#pragma config(Sensor, dgtl5,  encoderLeft,    sensorQuadEncoder)
#pragma config(Sensor, dgtl7,  encoderRight,   sensorQuadEncoder)
#pragma config(Sensor, dgtl9,  yellow1,        sensorLEDtoVCC)
#pragma config(Sensor, dgtl10, yellow2,        sensorLEDtoVCC)
#pragma config(Motor,  port2,           mFrontLift,    tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port3,           mBackLift,     tmotorVex393_MC29, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

/*---------------------------------------------------------------------------*/
/*                                                                           */
/*        Description: Competition template for VEX EDR                      */
/*                                                                           */
/*---------------------------------------------------------------------------*/

// This code is for the VEX cortex platform
#pragma platform(VEX2)

// Select Download method as "competition"
#pragma competitionControl(Competition)

//Main competition background code...do not modify!
#include "Vex_Competition_Includes.c"

/*---------------------------------------------------------------------------*/
/*                          Pre-Autonomous Functions                         */
/*                                                                           */
/*  You may want to perform some actions before the competition starts.      */
/*  Do them in the following function.  You must return from this function   */
/*  or the autonomous and usercontrol tasks will not be started.  This       */
/*  function is only called once after the cortex has been powered on and    */
/*  not every time that the robot is disabled.                               */
/*---------------------------------------------------------------------------*/

void pre_auton()
{
	// Set bStopTasksBetweenModes to false if you want to keep user created tasks
	// running between Autonomous and Driver controlled modes. You will need to
	// manage all user created tasks if set to false.
	bStopTasksBetweenModes = true;

	// Set bDisplayCompetitionStatusOnLcd to false if you don't want the LCD
	// used by the competition include file, for example, you might want
	// to display your team name on the LCD in this function.
	// bDisplayCompetitionStatusOnLcd = false;

	// All activities that occur before the competition starts
	// Example: clearing encoders, setting servo positions, ...
}

/*---------------------------------------------------------------------------*/
/*                                                                           */
/*                              Autonomous Task                              */
/*                                                                           */
/*  This task is used to control your robot during the autonomous phase of   */
/*  a VEX Competition.                                                       */
/*                                                                           */
/*  You must modify the code to add your own robot specific commands here.   */
/*---------------------------------------------------------------------------*/

task autonomous()
{
	// ..........................................................................
	// Insert user code here.
	// ..........................................................................

	// Remove this function call once you have "real" code.
	AutonomousCodePlaceholderForTesting();
}

/*---------------------------------------------------------------------------*/
/*                                                                           */
/*                              User Control Task                            */
/*                                                                           */
/*  This task is used to control your robot during the user control phase of */
/*  a VEX Competition.                                                       */
/*                                                                           */
/*  You must modify the code to add your own robot specific commands here.   */
/*---------------------------------------------------------------------------*/
bool fr = true;

task liftFront() {
	while(true) {

		if (vexRT[Btn5U]) {
			motor[port2] = 127;
			} else if (vexRT[Btn7D]) {
			motor[port2] = -70;
			} else if (vexRT[Btn5D]) {
			motor[port2] = -127;
			} else {
			motor[port2] = 0;
		}

		/*if (vexRT[Btn5U]) {
		motor[port2] = 127;
		fr = true;
		} else if (vexRT[Btn7D]) {
		motor[port2] = -70;
		fr = true;
		} else if (vexRT[Btn5D]) {
		motor[port2] = -127
		fr = false;
		while(vexRT[Btn5D]){};
		} else {
		if (fr) {
		motor[port2] = 0;
		} else {
		motor[port2] = -10;
		}*/
	}

}

task liftBack() {
	while(true) {

		if (vexRT[Btn6U]) {
			motor[port3] = 127;
			} else if (vexRT[Btn8D]) {
			motor[port3] = -70;
			} else if (vexRT[Btn6D]) {
			motor[port3] = -127;
			} else {
			motor[port3] = 0;
		}

	}

}

task BlinkGreen() {

}

task BlinkRed() {
	while (true) {
		SensorValue[red2] = SensorValue[red2] = SensorValue[red3] = true;
		delay(100);
		SensorValue[red2] = SensorValue[red2] = SensorValue[red3] = false;
		delay(1000);
	}

}

task DsensorVal() {
	int memoryL = 0;
	int memoryR = 0;
	int memoryLineTrackL;
	int memoryLineTrackR;
	SensorValue[encoderLeft] = 0;
	SensorValue[encoderRight] = 0;

	bLCDBacklight = true;
	while(true) {
		if (memoryL != SensorValue[encoderLeft]) {
			clearLCDLine(0);
			displayLCDNumber(0, 0, SensorValue[encoderLeft], 0.01);
			displayLCDNumber(0, 5, SensorValue[encoderRight], 0.01);
			memoryL = SensorValue[encoderLeft];
		}
		if (memoryR != SensorValue[encoderRight]) {
			clearLCDLine(0);
			displayLCDNumber(0, 0, SensorValue[encoderLeft], 0.01);
			displayLCDNumber(0, 5, SensorValue[encoderRight], 0.01);
			memoryR = SensorValue[encoderRight];
		}
		if (memoryLineTrackL != SensorValue[lineFollowLeft]) {
			clearLCDLine(1);
			displayLCDNumber(1, 0, SensorValue[lineFollowLeft], 0.01);
			displayLCDNumber(1, 6, SensorValue[lineFollowRight], 0.01);
			memoryLineTrackL = SensorValue[lineFollowLeft];
		}
		if (memoryLineTrackR != SensorValue[lineFollowRight]) {
			clearLCDLine(1);
			displayLCDNumber(1, 0, SensorValue[lineFollowLeft], 0.01);
			displayLCDNumber(1, 6, SensorValue[lineFollowRight], 0.01);
			memoryLineTrackR = SensorValue[lineFollowRight];
		}
	}
}

void leftMotor(int power) {
	motor[port1] = motor[port4] = motor[port5] = motor[port6] = power;
}
void rightMotor(int power) {
	motor[port7] = motor[port8] = motor[port9] = motor[port10] = -power;
}

void PIDTest() {
	float lastErrorL = 0;
	float lastErrorR = 0;
	float erTleft = 0;
	float erTright = 0;

	int targetL = -750
	int targetR = -750

	float kp = 0.65
	float ki = 0.1
	float kd = 1.9

	while(nLCDButtons != 1) {

		float errorL = SensorValue[encoderLeft] - targetL;
		float errorR = SensorValue[encoderRight] - targetR;

		if (abs(errorL) < 20) {
			erTleft += errorL;
			} else {
			erTleft = 0;
		}

		if (abs(errorR) < 20) {
			erTright += errorR;
			} else {
			erTright = 0;
		}


		// Calculate PID Values

		float calcPleft =  errorL								* kp;
		float calcPrigh =  errorR 							* kp;
		float calcIleft =  erTleft							* ki;
		float calcIrigh =  erTright 						*	ki;
		float calcDleft = (errorL - lastErrorL) * kd;
		float calcDrigh = (errorR - lastErrorR) * kd;

		lastErrorL = errorL;
		lastErrorR = errorR;
		delay(25);

		float outputL = calcPleft + calcIleft + calcDleft;
		float outputR = calcPrigh + calcIrigh + calcDrigh;
		writeDebugStream("%i", errorL);
		writeDebugStream("%s", " ");
		writeDebugStreamLine("%i", errorR);

		leftMotor(outputL);
		rightMotor(outputR);
	}
	leftMotor(0);
	rightMotor(0);
	writeDebugStream("%s", "Let go");
	while(nLCDButtons == 1) {}
}

// PRODUCTION PID LOOP

bool targetsSatisfactory = false;
int globalNErrorL = 0;
int globalNErrorR = 0;
int globalAccuracy = 5;
int globalMaxSpeed = 127;

task linkTargetSatisfactory() {
	delay(200);
	while((abs(globalNErrorL) > globalAccuracy) && (abs(globalNErrorR) > globalAccuracy)) {}
	delay(500);
	targetsSatisfactory = true;
}

void moveMotors(int leftTarget, int rightTarget) {
	SensorValue[encoderLeft] = 0;
	SensorValue[encoderRight] = 0;
	float lastErrorL = 0;
	float lastErrorR = 0;
	float erTleft = 0;
	float erTright = 0;

	int targetL = -leftTarget;
	int targetR = -rightTarget;

	float kp = 0.75;
	float ki = 0.02
	float kd = 1.9;
	startTask(linkTargetSatisfactory);

	while(!targetsSatisfactory) {

		float errorL = SensorValue[encoderLeft] - targetL;
		float errorR = SensorValue[encoderRight] - targetR;
		globalNErrorL = errorL;
		globalNErrorR = errorR;

		if (abs(errorL) < 20) {
			erTleft += errorL;
			} else {
			erTleft = 0;
		}

		if (abs(errorR) < 20) {
			erTright += errorR;
			} else {
			erTright = 0;
		}


		// Calculate PID Values

		float calcPleft =  errorL								* kp;
		float calcPrigh =  errorR 							* kp;
		float calcIleft =  erTleft							* ki;
		float calcIrigh =  erTright 						*	ki;
		float calcDleft = (errorL - lastErrorL) * kd;
		float calcDrigh = (errorR - lastErrorR) * kd;

		lastErrorL = errorL;
		lastErrorR = errorR;
		delay(25);

		float outputL = calcPleft + calcIleft + calcDleft;
		float outputR = calcPrigh + calcIrigh + calcDrigh;

		if (abs(outputL) > globalMaxSpeed) {
			if (outputL > 0) {
				outputL = globalMaxSpeed;
			}
			if (outputL < 0) {
				outputL = -globalMaxSpeed;
			}
		}
		if (abs(outputR) > globalMaxSpeed) {
			if (outputR > 0) {
				outputR = globalMaxSpeed;
			}
			if (outputR < 0) {
				outputR = -globalMaxSpeed;
			}
		}

		leftMotor(outputL);
		rightMotor(outputR);
	}
	stopTask(linkTargetSatisfactory);
	leftMotor(0);
	rightMotor(0);
	targetsSatisfactory = false;
}

task frontUp() {
	motor[mFrontLift] = 100;
	delay(1100);
	motor[mFrontLift] = 10;
}

task frontDown() {
	motor[mFrontLift] = -100;
	while(!SensorValue[frontLift]) {}
	motor[mFrontLift] = -10;
}

task frontDownDelay() {
	motor[mFrontLift] = -100;
	delay(1100);
	motor[mFrontLift] = -10;
}

task backDownDelay() {
	motor[mBackLift] = -100;
	delay(1100);
	motor[mBackLift] = -10;
}
task backUp() {
	motor[mBackLift] = 100;
	delay(1100);
	motor[mBackLift] = 10;
}

task backDown() {
	motor[mBackLift] = -100;
	while(!SensorValue[backLift]) {}
	motor[mBackLift] = -10;
}

void ramFront(int de) {
	leftMotor(127);
	rightMotor(127);
	delay(de);
	leftMotor(0);
	rightMotor(0);
}

void ramBack(int de) {
	leftMotor(-127);
	rightMotor(-127);
	delay(de);
	leftMotor(0);
	rightMotor(0);
}
int globalLSThreshold = 2800;
void alignWithTapeSpeed(int l, int r) {
	leftMotor(l);
	rightMotor(r);
	bool leftComplete = false;
	bool rightComplete = false;
	while(!leftComplete || !rightComplete) {
		if (SensorValue[lineFollowLeft] < globalLSThreshold) {
			leftMotor(-6);
			leftComplete = true;
		}
		if (SensorValue[lineFollowRight] < globalLSThreshold) {
			rightMotor(-6);
			rightComplete = true;
		}
	}

}

void skills() {
	globalAccuracy = 6;
	globalMaxSpeed = 80;

	// Get First Mogo
	startTask(frontDown);
	moveMotors(1000, 1000);
	leftMotor(20);
	rightMotor(20);
	delay(100);
	startTask(frontUp);
	delay(700);

	// Rotate 360 And Into Cone, Lift Up
	globalMaxSpeed = 50;
	globalAccuracy = 12;
	moveMotors(670, -670);
	startTask(backDown);
	delay(400);
	moveMotors(-1000, -1000);
	startTask(backUp);
	delay(700);

	// Go to Red 5pt Right
	moveMotors(-1010, -1010);
	startTask(backDown);
	delay(1000);
	moveMotors(500, 500);

	//Rotate To Front
	moveMotors(560, -560);
	moveMotors(380, 380);
	leftMotor(36);
	rightMotor(28);
	delay(2000);

	//Ram
	moveMotors(-400, -400);
	ramFront(1000);

	//Back and Correct
	moveMotors(-500, -500);
	alignWithTapeSpeed(-60, -60);
	moveMotors(0, 1315);

	// Forward towards Fall for Ram
	moveMotors(-700, -700);





}

void ekinSkills() {
	globalAccuracy = 3;
	globalMaxSpeed = 80;

	//Get Past First Line
	moveMotors(410,410);
	//Ram Into Tape
	alignWithTapeSpeed(30, 30);

	startTask(frontDown);
	//Turn towards yellow cones (Old 100, -130)
	moveMotors(0, -230);
	//Push cones
	moveMotors(700, 700);
	//Back up (Old -250,-250)
	moveMotors(-90, -90);
	//Turn towards mogo (Old: -155, 155)
	globalMaxSpeed = 70;
	moveMotors(-290,290);
	globalMaxSpeed = 80;

	//Move forwards to scoop mogo
	moveMotors(330,330);
	leftMotor(20);
	rightMotor(20);
	startTask(frontUp);
	delay(1300);
	startTask(backDown);
	globalAccuracy = 40;
	moveMotors(-1200, -1200);
	startTask(backUp);
	delay(700);

	/*globalAccuracy = 5;
	moveMotors(310,-310);
	// Go to Red 5pt Right
	moveMotors(-1120, -1120);
	leftMotor(-30);
	rightMotor(-30);
	startTask(backDown);
	delay(1000);
	globalMaxSpeed = 55;
	delay(1000);
	moveMotors(500, 500);

	//Rotate To Front
	startTask(backUp);
	moveMotors(510, -510);
	moveMotors(390, 390);
	leftMotor(36);
	rightMotor(18);
	delay(3000);

	//Ram
	moveMotors(-400, -400);
	ramFront(1300);

	//Back and Correct
	moveMotors(-510, -510);
	globalMaxSpeed=45;
	alignWithTapeSpeed(-60, -60);

	//Back Up
	globalMaxSpeed = 80;
	moveMotors(-200,-200);
	moveMotors(250,-250);
	moveMotors(-660,-660);
	leftMotor(-18);
	rightMotor(-36);
	delay(2000);



	// Move First Cones Away
	/*globalMaxSpeed = 60;
	moveMotors(1710, 1710);
	moveMotors(-270, -270);
	globalMaxSpeed = 127;
	//Turn To Cone And Lift
	globalMaxSpeed = 70;
	moveMotors(-145, 145);
	globalMaxSpeed = 127;
	moveMotors(400, 400);
	startTask(frontUp);
	startTask(backDown);
	delay(800);

	moveMotors(-820, -810);
	startTask(backUp);

	//Turn To Scoring Bar
	moveMotors(-320, 320);
	moveMotors(1070, 1050);
	startTask(frontDown);*/

}


void legitSkills(){
	globalAccuracy = 3;
	globalMaxSpeed = 80;

	//Get Past First Line
	moveMotors(410,410);
	//Ram Into Tape
	alignWithTapeSpeed(30, 30);

	startTask(frontDownDelay);
	//Turn towards yellow cones (Old 100, -130)
	moveMotors(0, -240);
	//Push cones
	moveMotors(780, 780);
	//Back up
	startTask(frontUp);
	moveMotors(-90, -90);
	//Turn towards mogo (Old: -155, 155)
	globalMaxSpeed = 70;
	moveMotors(-290,290);
	startTask(frontDownDelay);
	moveMotors(-200,-200);

	globalMaxSpeed = 80;

	//Move forwards to scoop mogo
	//moveMotors(350,350);
	leftMotor(90);
	rightMotor(90);
	delay(800);
	leftMotor(10);
	rightMotor(10);
	startTask(frontUp);
	delay(1300);
	startTask(backDownDelay);
	globalAccuracy = 40;
	moveMotors(-1100, -1100);
	startTask(backUp);
	delay(700);


	globalAccuracy = 5;
	moveMotors(310,-310);
	// Go to Red 5pt Right
	moveMotors(-1120, -1120);
	leftMotor(-30);
	rightMotor(-30);
	startTask(backDownDelay);
	delay(1000);
	globalMaxSpeed = 55;
	delay(1000);
	moveMotors(500, 500);
/*
	//Rotate To Front
	startTask(backUp);
	moveMotors(510, -510);
	moveMotors(390, 390);
	leftMotor(36);
	rightMotor(18);
	delay(3000);

	//Ram
	moveMotors(-400, -400);
	ramFront(1300);

	//Back and Correct
	moveMotors(-510, -510);
	globalMaxSpeed=45;
	alignWithTapeSpeed(-60, -60);

	//Back Up
	globalMaxSpeed = 80;
	moveMotors(-200,-200);
	moveMotors(250,-250);
	moveMotors(-660,-660);
	leftMotor(-18);
	rightMotor(-36);
	delay(2000); */
}

task usercontrol()
{
	bool driveMode = true;
	// User control code here, inside the loop
	//startTask(liftFront);
	//	startTask(liftBack);
	startTask(BlinkGreen);
	startTask(BlinkRed);
	startTask(DsensorVal);
	while (true)
	{

		SensorValue[yellow1] = SensorValue[frontLift];
		SensorValue[yellow2] = SensorValue[backLift];
		if (driveMode) {
			//	motor[port1] = motor[port4] = motor[port5] = motor[port6] = vexRT[Ch3] + vexRT[Ch1];
			//	motor[port7] = motor[port8] = motor[port9] = motor[port10] = -vexRT[Ch3] + vexRT[Ch1];
			} else {
			motor[port1] = motor[port4] = motor[port5] = motor[port6] = vexRT[Ch3] + vexRT[Ch1];
			motor[port7] = motor[port8] = motor[port9] = motor[port10] = -vexRT[Ch3] + vexRT[Ch1];
		}
		if (vexRT[Btn7L]) {
			while(vexRT[Btn7L]){}
			startTask(liftFront);
			startTask(liftBack);
			driveMode = !driveMode;
		}

		if (nLCDButtons == 2) {
			leftMotor(-50);
			rightMotor(-50);
			while(nLCDButtons == 2) {}
			leftMotor(0);
			rightMotor(0);

		}

		if (vexRT[Btn7R]) {
			while(vexRT[Btn7R]) {}
			legitSkills();
		}

		if (nLCDButtons == 4) {
			SensorValue[encoderLeft] = 0;
			SensorValue[encoderRight] = 0;
		}

		if(vexRT[Btn8R]){
			startTask(frontDownDelay);
		}


	}
}
